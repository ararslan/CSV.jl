{
    "docs": [
        {
            "location": "/", 
            "text": "CSV.jl Documentation\n\n\n\n\nHigh-level interface\n\n\n#\n\n\nCSV.read\n \n \nFunction\n.\n\n\nparses a delimited file into a Julia structure (a DataFrame by default, but any \nData.Sink\n may be given).\n\n\n\n\nfullpath\n; can be a file name (string) or other \nIO\n instance\n\n\nsink\n; a \nDataFrame\n by default, but may also be other \nData.Sink\n types that support the \nAbstractTable\n interface\n\n\ndelim::Union{Char,UInt8}\n; how fields in the file are delimited\n\n\nquotechar::Union{Char,UInt8}\n; the character that indicates a quoted field that may contain the \ndelim\n or newlines\n\n\nescapechar::Union{Char,UInt8}\n; the character that escapes a \nquotechar\n in a quoted field\n\n\nnull::String\n; an ascii string that indicates how NULL values are represented in the dataset\n\n\nheader\n; column names can be provided manually as a complete Vector{String}, or as an Int/Range which indicates the row/rows that contain the column names\n\n\ndatarow::Int\n; specifies the row on which the actual data starts in the file; by default, the data is expected on the next row after the header row(s)\n\n\ntypes\n; column types can be provided manually as a complete Vector{DataType}, or in a Dict to reference a column by name or number\n\n\ndateformat::Union{AbstractString,Dates.DateFormat}\n; how all dates/datetimes are represented in the dataset\n\n\nfooterskip::Int\n; indicates the number of rows to skip at the end of the file\n\n\nrows_for_type_detect::Int=100\n; indicates how many rows should be read to infer the types of columns\n\n\nrows::Int\n; indicates the total number of rows to read from the file; by default the file is pre-parsed to count the # of rows\n\n\nuse_mmap::Bool=true\n; whether the underlying file will be mmapped or not while parsing\n\n\n\n\nNote by default, \"string\" or text columns will be parsed as the \nWeakRefString\n type. This is a custom type that only stores a pointer to the actual byte data + the number of bytes. To convert a \nString\n to a standard Julia string type, just call \nstring(::String)\n, this also works on an entire column \nstring(::NullableVector{String})\n. Oftentimes, however, it can be convenient to work with \nWeakRefStrings\n depending on the ultimate use, such as transfering the data directly to another system and avoiding all the intermediate byte copying.\n\n\nExample usage:\n\n\njulia\n dt = CSV.read(\nbids.csv\n)\n7656334\u00d79 DataFrames.DataFrame\n\u2502 Row     \u2502 bid_id  \u2502 bidder_id                               \u2502 auction \u2502 merchandise      \u2502 device      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1       \u2502 0       \u2502 \n8dac2b259fd1c6d1120e519fb1ac14fbqvax8\n \u2502 \newmzr\n \u2502 \njewelry\n        \u2502 \nphone0\n    \u2502\n\u2502 2       \u2502 1       \u2502 \n668d393e858e8126275433046bbd35c6tywop\n \u2502 \naeqok\n \u2502 \nfurniture\n      \u2502 \nphone1\n    \u2502\n\u2502 3       \u2502 2       \u2502 \naa5f360084278b35d746fa6af3a7a1a5ra3xe\n \u2502 \nwa00e\n \u2502 \nhome goods\n     \u2502 \nphone2\n    \u2502\n...\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nread\n(\nfullpath\n::\nUnion{AbstractString,IO}\n)\n\n    defined at\n    \nsrc/Source.jl:266\n\n\n\n\n\n    \nread\n(\n\n    \nfullpath\n::\nUnion{AbstractString,IO}\n,\n\n    \nsink\n\n\n)\n\n    defined at\n    \nsrc/Source.jl:266\n\n\n\n\n\n\n\n#\n\n\nCSV.write\n \n \nFunction\n.\n\n\nwrite a \nsource::Data.Source\n out to a \nCSV.Sink\n\n\n\n\nio::Union{String,IO}\n; a filename (String) or \nIO\n type to write the \nsource\n to\n\n\nsource\n; a \nData.Source\n type\n\n\ndelim::Union{Char,UInt8}\n; how fields in the file will be delimited\n\n\nquotechar::Union{Char,UInt8}\n; the character that indicates a quoted field that may contain the \ndelim\n or newlines\n\n\nescapechar::Union{Char,UInt8}\n; the character that escapes a \nquotechar\n in a quoted field\n\n\nnull::String\n; the ascii string that indicates how NULL values will be represented in the dataset\n\n\ndateformat\n; how dates/datetimes will be represented in the dataset\n\n\nquotefields::Bool\n; whether all fields should be quoted or not\n\n\nheader::Bool\n; whether to write out the column names from \nsource\n\n\nappend::Bool\n; start writing data at the end of \nio\n; by default, \nio\n will be reset to its beginning before writing\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nwrite\n(\n\n    \nio\n::\nUnion{AbstractString,IO}\n,\n\n    \nsource\n\n\n)\n\n    defined at\n    \nsrc/Sink.jl:122\n\n\n\n\n\n\n\n#\n\n\nCSV.Options\n \n \nType\n.\n\n\nRepresents the various configuration settings for csv file parsing.\n\n\n\n\ndelim\n::Union{Char,UInt8} = how fields in the file are delimited\n\n\nquotechar\n::Union{Char,UInt8} = the character that indicates a quoted field that may contain the \ndelim\n or newlines\n\n\nescapechar\n::Union{Char,UInt8} = the character that escapes a \nquotechar\n in a quoted field\n\n\nnull\n::String = indicates how NULL values are represented in the dataset\n\n\ndateformat\n::Union{AbstractString,Dates.DateFormat} = how dates/datetimes are represented in the dataset\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nOptions\n(\n)\n\n    defined at\n    \nsrc/CSV.jl:72\n\n\n\n\n\n    \nOptions\n(\n\n    \ndelim\n::\nUInt8\n,\n\n    \nquotechar\n::\nUInt8\n,\n\n    \nescapechar\n::\nUInt8\n,\n\n    \nseparator\n::\nUInt8\n,\n\n    \ndecimal\n::\nUInt8\n,\n\n    \nnull\n::\nString\n,\n\n    \nnullcheck\n::\nBool\n,\n\n    \ndateformat\n::\nBase.Dates.DateFormat\n,\n\n    \ndatecheck\n::\nBool\n\n\n)\n\n    defined at\n    \nsrc/CSV.jl:61\n\n\n\n\n\n    \nOptions\n(\n\n    \ndelim\n,\n\n    \nquotechar\n,\n\n    \nescapechar\n,\n\n    \nseparator\n,\n\n    \ndecimal\n,\n\n    \nnull\n,\n\n    \nnullcheck\n,\n\n    \ndateformat\n,\n\n    \ndatecheck\n\n\n)\n\n    defined at\n    \nsrc/CSV.jl:61\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nLower-level utilities\n\n\n#\n\n\nCSV.Source\n \n \nType\n.\n\n\nconstructs a \nCSV.Source\n file ready to start parsing data from\n\n\nimplements the \nData.Source\n interface for providing convenient \nData.stream!\n methods for various \nData.Sink\n types\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nSource\n(\n)\n\n    defined at\n    \nsrc/Source.jl:59\n\n\n\n\n\n    \nSource\n{\nI\n<\n:IO\n}\n(\n\n    \nschema\n::\nDataStreams.Data.Schema\n,\n\n    \noptions\n::\nCSV.Options\n,\n\n    \ndata\n::\nI\n,\n\n    \ndatapos\n::\nInt64\n,\n\n    \nfullpath\n::\nString\n\n\n)\n\n    defined at\n    \nsrc/CSV.jl:90\n\n\n\n\n\n    \nSource\n(\nfullpath\n::\nUnion{AbstractString,IO}\n)\n\n    defined at\n    \nsrc/Source.jl:28\n\n\n\n\n\n    \nSource\n{\nI\n}\n(\ns\n::\nCSV.Sink{I}\n)\n\n    defined at\n    \nsrc/Source.jl:176\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nCSV.Sink\n \n \nType\n.\n\n\nconstructs a \nCSV.Sink\n file ready to start writing data to\n\n\nimplements the \nData.Sink\n interface for providing convenient \nData.stream!\n methods for various \nData.Source\n types\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nSink\n{\nI\n<\n:IO\n}\n(\n\n    \nschema\n::\nDataStreams.Data.Schema\n,\n\n    \noptions\n::\nCSV.Options\n,\n\n    \ndata\n::\nI\n,\n\n    \ndatapos\n::\nInt64\n,\n\n    \nquotefields\n::\nBool\n\n\n)\n\n    defined at\n    \nsrc/CSV.jl:109\n\n\n\n\n\n    \nSink\n(\ns\n::\nCSV.Source\n)\n\n    defined at\n    \nsrc/Sink.jl:8\n\n\n\n\n\n    \nSink\n(\ns\n::\nCSV.Source\n, \nio\n::\nIOStream\n)\n\n    defined at\n    \nsrc/Sink.jl:17\n\n\n\n\n\n    \nSink\n(\n\n    \ns\n::\nCSV.Source\n,\n\n    \nfile\n::\nAbstractString\n\n\n)\n\n    defined at\n    \nsrc/Sink.jl:21\n\n\n\n\n\n    \nSink\n(\nio\n::\nUnion{AbstractString,IO}\n)\n\n    defined at\n    \nsrc/Sink.jl:34\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nCSV.parsefield\n \n \nFunction\n.\n\n\nio\n is an \nIO\n type that is positioned at the first byte/character of an delimited-file field (i.e. a single cell) leading whitespace is ignored for Integer and Float types. returns a \nTuple{T,Bool}\n with a value \n bool saying whether the field contains a null value or not Specialized methods exist for Integer, Float, String, Date, and DateTime. For other types \nT\n, a generic fallback requires \nzero(T)\n and \nparse(T, str::String)\n to be defined. field is null if the next delimiter or newline is encountered before any other characters. the field value may also be wrapped in \nopt.quotechar\n; two consecutive \nopt.quotechar\n results in a null field \nopt.null\n is also checked if there is a custom value provided (i.e. \"NA\", \"\\N\", etc.) For numeric fields, if field is non-null and non-digit characters are encountered at any point before a delimiter or newline, an error is thrown\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:99\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:99\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:99\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:99\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:149\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:149\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:149\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:149\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:Integer\n}\n(\nio\n::\nIO\n, \n::\nType{T}\n)\n\n    defined at\n    \nsrc/parsefields.jl:69\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:Integer\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:69\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:Integer\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:69\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:Integer\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:69\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\nio\n::\nIO\n, \n::\nType{T}\n)\n\n    defined at\n    \nsrc/parsefields.jl:131\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:131\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:131\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractFloat\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:131\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\nio\n::\nIO\n, \n::\nType{T}\n)\n\n    defined at\n    \nsrc/parsefields.jl:183\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:183\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:183\n\n\n\n\n\n    \nparsefield\n{\nT\n<\n:AbstractString\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:183\n\n\n\n\n\n    \nparsefield\n(\nio\n::\nIO\n, \n::\nType{Date}\n)\n\n    defined at\n    \nsrc/parsefields.jl:221\n\n\n\n\n\n    \nparsefield\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{Date}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:221\n\n\n\n\n\n    \nparsefield\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{Date}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:221\n\n\n\n\n\n    \nparsefield\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{Date}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:221\n\n\n\n\n\n    \nparsefield\n(\nio\n::\nIO\n, \n::\nType{DateTime}\n)\n\n    defined at\n    \nsrc/parsefields.jl:269\n\n\n\n\n\n    \nparsefield\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{DateTime}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:269\n\n\n\n\n\n    \nparsefield\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{DateTime}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:269\n\n\n\n\n\n    \nparsefield\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{DateTime}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:269\n\n\n\n\n\n    \nparsefield\n{\nT\n}\n(\nio\n::\nIO\n, \n::\nType{T}\n)\n\n    defined at\n    \nsrc/parsefields.jl:338\n\n\n\n\n\n    \nparsefield\n{\nT\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:338\n\n\n\n\n\n    \nparsefield\n{\nT\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:338\n\n\n\n\n\n    \nparsefield\n{\nT\n}\n(\n\n    \nio\n::\nIO\n,\n\n    \n::\nType{T}\n,\n\n    \nopt\n::\nCSV.Options\n,\n\n    \nrow\n,\n\n    \ncol\n\n\n)\n\n    defined at\n    \nsrc/parsefields.jl:338\n\n\n\n\n\n\n\n#\n\n\nCSV.readline\n \n \nMethod\n.\n\n\nread a single line from \nio\n (any \nIO\n type) as a string, accounting for potentially embedded newlines in quoted fields (e.g. value1, value2, \"value3 with   embedded newlines\"). Can optionally provide a \nbuf::IOBuffer\n type for buffer resuse\n\n\nsource\n\n\n#\n\n\nCSV.readsplitline\n \n \nFunction\n.\n\n\nread a single line from \nio\n (any \nIO\n type) as a \nVector{String}\n with elements being delimited fields. Can optionally provide a \nbuf::IOBuffer\n type for buffer resuse\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nreadsplitline\n(\nio\n::\nIO\n)\n\n    defined at\n    \nsrc/io.jl:31\n\n\n\n\n\n    \nreadsplitline\n(\nio\n::\nIO\n, \nd\n::\nUInt8\n)\n\n    defined at\n    \nsrc/io.jl:31\n\n\n\n\n\n    \nreadsplitline\n(\n\n    \nio\n::\nIO\n,\n\n    \nd\n::\nUInt8\n,\n\n    \nq\n::\nUInt8\n\n\n)\n\n    defined at\n    \nsrc/io.jl:31\n\n\n\n\n\n    \nreadsplitline\n(\n\n    \nio\n::\nIO\n,\n\n    \nd\n::\nUInt8\n,\n\n    \nq\n::\nUInt8\n,\n\n    \ne\n::\nUInt8\n\n\n)\n\n    defined at\n    \nsrc/io.jl:31\n\n\n\n\n\n    \nreadsplitline\n(\n\n    \nio\n::\nIO\n,\n\n    \nd\n::\nUInt8\n,\n\n    \nq\n::\nUInt8\n,\n\n    \ne\n::\nUInt8\n,\n\n    \nbuf\n::\nBase.AbstractIOBuffer{Array{UInt8,1}}\n\n\n)\n\n    defined at\n    \nsrc/io.jl:31\n\n\n\n\n\n\n\n#\n\n\nCSV.countlines\n \n \nMethod\n.\n\n\ncount the number of lines in a file, accounting for potentially embedded newlines in quoted fields\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#csvjl-documentation", 
            "text": "", 
            "title": "CSV.jl Documentation"
        }, 
        {
            "location": "/#high-level-interface", 
            "text": "#  CSV.read     Function .  parses a delimited file into a Julia structure (a DataFrame by default, but any  Data.Sink  may be given).   fullpath ; can be a file name (string) or other  IO  instance  sink ; a  DataFrame  by default, but may also be other  Data.Sink  types that support the  AbstractTable  interface  delim::Union{Char,UInt8} ; how fields in the file are delimited  quotechar::Union{Char,UInt8} ; the character that indicates a quoted field that may contain the  delim  or newlines  escapechar::Union{Char,UInt8} ; the character that escapes a  quotechar  in a quoted field  null::String ; an ascii string that indicates how NULL values are represented in the dataset  header ; column names can be provided manually as a complete Vector{String}, or as an Int/Range which indicates the row/rows that contain the column names  datarow::Int ; specifies the row on which the actual data starts in the file; by default, the data is expected on the next row after the header row(s)  types ; column types can be provided manually as a complete Vector{DataType}, or in a Dict to reference a column by name or number  dateformat::Union{AbstractString,Dates.DateFormat} ; how all dates/datetimes are represented in the dataset  footerskip::Int ; indicates the number of rows to skip at the end of the file  rows_for_type_detect::Int=100 ; indicates how many rows should be read to infer the types of columns  rows::Int ; indicates the total number of rows to read from the file; by default the file is pre-parsed to count the # of rows  use_mmap::Bool=true ; whether the underlying file will be mmapped or not while parsing   Note by default, \"string\" or text columns will be parsed as the  WeakRefString  type. This is a custom type that only stores a pointer to the actual byte data + the number of bytes. To convert a  String  to a standard Julia string type, just call  string(::String) , this also works on an entire column  string(::NullableVector{String}) . Oftentimes, however, it can be convenient to work with  WeakRefStrings  depending on the ultimate use, such as transfering the data directly to another system and avoiding all the intermediate byte copying.  Example usage:  julia  dt = CSV.read( bids.csv )\n7656334\u00d79 DataFrames.DataFrame\n\u2502 Row     \u2502 bid_id  \u2502 bidder_id                               \u2502 auction \u2502 merchandise      \u2502 device      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1       \u2502 0       \u2502  8dac2b259fd1c6d1120e519fb1ac14fbqvax8  \u2502  ewmzr  \u2502  jewelry         \u2502  phone0     \u2502\n\u2502 2       \u2502 1       \u2502  668d393e858e8126275433046bbd35c6tywop  \u2502  aeqok  \u2502  furniture       \u2502  phone1     \u2502\n\u2502 3       \u2502 2       \u2502  aa5f360084278b35d746fa6af3a7a1a5ra3xe  \u2502  wa00e  \u2502  home goods      \u2502  phone2     \u2502\n...  source  Methods   \n     read ( fullpath :: Union{AbstractString,IO} ) \n    defined at\n     src/Source.jl:266   \n     read ( \n     fullpath :: Union{AbstractString,IO} ,      sink  ) \n    defined at\n     src/Source.jl:266    #  CSV.write     Function .  write a  source::Data.Source  out to a  CSV.Sink   io::Union{String,IO} ; a filename (String) or  IO  type to write the  source  to  source ; a  Data.Source  type  delim::Union{Char,UInt8} ; how fields in the file will be delimited  quotechar::Union{Char,UInt8} ; the character that indicates a quoted field that may contain the  delim  or newlines  escapechar::Union{Char,UInt8} ; the character that escapes a  quotechar  in a quoted field  null::String ; the ascii string that indicates how NULL values will be represented in the dataset  dateformat ; how dates/datetimes will be represented in the dataset  quotefields::Bool ; whether all fields should be quoted or not  header::Bool ; whether to write out the column names from  source  append::Bool ; start writing data at the end of  io ; by default,  io  will be reset to its beginning before writing   source  Methods   \n     write ( \n     io :: Union{AbstractString,IO} ,      source  ) \n    defined at\n     src/Sink.jl:122    #  CSV.Options     Type .  Represents the various configuration settings for csv file parsing.   delim ::Union{Char,UInt8} = how fields in the file are delimited  quotechar ::Union{Char,UInt8} = the character that indicates a quoted field that may contain the  delim  or newlines  escapechar ::Union{Char,UInt8} = the character that escapes a  quotechar  in a quoted field  null ::String = indicates how NULL values are represented in the dataset  dateformat ::Union{AbstractString,Dates.DateFormat} = how dates/datetimes are represented in the dataset   source  Methods   \n     Options ( ) \n    defined at\n     src/CSV.jl:72   \n     Options ( \n     delim :: UInt8 ,      quotechar :: UInt8 ,      escapechar :: UInt8 ,      separator :: UInt8 ,      decimal :: UInt8 ,      null :: String ,      nullcheck :: Bool ,      dateformat :: Base.Dates.DateFormat ,      datecheck :: Bool  ) \n    defined at\n     src/CSV.jl:61   \n     Options ( \n     delim ,      quotechar ,      escapechar ,      separator ,      decimal ,      null ,      nullcheck ,      dateformat ,      datecheck  ) \n    defined at\n     src/CSV.jl:61    Hiding 1 method defined outside of this package.", 
            "title": "High-level interface"
        }, 
        {
            "location": "/#lower-level-utilities", 
            "text": "#  CSV.Source     Type .  constructs a  CSV.Source  file ready to start parsing data from  implements the  Data.Source  interface for providing convenient  Data.stream!  methods for various  Data.Sink  types  source  Methods   \n     Source ( ) \n    defined at\n     src/Source.jl:59   \n     Source { I < :IO } ( \n     schema :: DataStreams.Data.Schema ,      options :: CSV.Options ,      data :: I ,      datapos :: Int64 ,      fullpath :: String  ) \n    defined at\n     src/CSV.jl:90   \n     Source ( fullpath :: Union{AbstractString,IO} ) \n    defined at\n     src/Source.jl:28   \n     Source { I } ( s :: CSV.Sink{I} ) \n    defined at\n     src/Source.jl:176    Hiding 1 method defined outside of this package.  #  CSV.Sink     Type .  constructs a  CSV.Sink  file ready to start writing data to  implements the  Data.Sink  interface for providing convenient  Data.stream!  methods for various  Data.Source  types  source  Methods   \n     Sink { I < :IO } ( \n     schema :: DataStreams.Data.Schema ,      options :: CSV.Options ,      data :: I ,      datapos :: Int64 ,      quotefields :: Bool  ) \n    defined at\n     src/CSV.jl:109   \n     Sink ( s :: CSV.Source ) \n    defined at\n     src/Sink.jl:8   \n     Sink ( s :: CSV.Source ,  io :: IOStream ) \n    defined at\n     src/Sink.jl:17   \n     Sink ( \n     s :: CSV.Source ,      file :: AbstractString  ) \n    defined at\n     src/Sink.jl:21   \n     Sink ( io :: Union{AbstractString,IO} ) \n    defined at\n     src/Sink.jl:34    Hiding 1 method defined outside of this package.  #  CSV.parsefield     Function .  io  is an  IO  type that is positioned at the first byte/character of an delimited-file field (i.e. a single cell) leading whitespace is ignored for Integer and Float types. returns a  Tuple{T,Bool}  with a value   bool saying whether the field contains a null value or not Specialized methods exist for Integer, Float, String, Date, and DateTime. For other types  T , a generic fallback requires  zero(T)  and  parse(T, str::String)  to be defined. field is null if the next delimiter or newline is encountered before any other characters. the field value may also be wrapped in  opt.quotechar ; two consecutive  opt.quotechar  results in a null field  opt.null  is also checked if there is a custom value provided (i.e. \"NA\", \"\\N\", etc.) For numeric fields, if field is non-null and non-digit characters are encountered at any point before a delimiter or newline, an error is thrown  source  Methods   \n     parsefield { T < :AbstractFloat } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T}  ) \n    defined at\n     src/parsefields.jl:99   \n     parsefield { T < :AbstractFloat } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:99   \n     parsefield { T < :AbstractFloat } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:99   \n     parsefield { T < :AbstractFloat } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:99   \n     parsefield { T < :AbstractString } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T}  ) \n    defined at\n     src/parsefields.jl:149   \n     parsefield { T < :AbstractString } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:149   \n     parsefield { T < :AbstractString } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:149   \n     parsefield { T < :AbstractString } ( \n     io :: Base.AbstractIOBuffer{Array{UInt8,1}} ,      :: Type{T} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:149   \n     parsefield { T < :Integer } ( io :: IO ,  :: Type{T} ) \n    defined at\n     src/parsefields.jl:69   \n     parsefield { T < :Integer } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:69   \n     parsefield { T < :Integer } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:69   \n     parsefield { T < :Integer } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:69   \n     parsefield { T < :AbstractFloat } ( io :: IO ,  :: Type{T} ) \n    defined at\n     src/parsefields.jl:131   \n     parsefield { T < :AbstractFloat } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:131   \n     parsefield { T < :AbstractFloat } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:131   \n     parsefield { T < :AbstractFloat } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:131   \n     parsefield { T < :AbstractString } ( io :: IO ,  :: Type{T} ) \n    defined at\n     src/parsefields.jl:183   \n     parsefield { T < :AbstractString } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:183   \n     parsefield { T < :AbstractString } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:183   \n     parsefield { T < :AbstractString } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:183   \n     parsefield ( io :: IO ,  :: Type{Date} ) \n    defined at\n     src/parsefields.jl:221   \n     parsefield ( \n     io :: IO ,      :: Type{Date} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:221   \n     parsefield ( \n     io :: IO ,      :: Type{Date} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:221   \n     parsefield ( \n     io :: IO ,      :: Type{Date} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:221   \n     parsefield ( io :: IO ,  :: Type{DateTime} ) \n    defined at\n     src/parsefields.jl:269   \n     parsefield ( \n     io :: IO ,      :: Type{DateTime} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:269   \n     parsefield ( \n     io :: IO ,      :: Type{DateTime} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:269   \n     parsefield ( \n     io :: IO ,      :: Type{DateTime} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:269   \n     parsefield { T } ( io :: IO ,  :: Type{T} ) \n    defined at\n     src/parsefields.jl:338   \n     parsefield { T } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options  ) \n    defined at\n     src/parsefields.jl:338   \n     parsefield { T } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row  ) \n    defined at\n     src/parsefields.jl:338   \n     parsefield { T } ( \n     io :: IO ,      :: Type{T} ,      opt :: CSV.Options ,      row ,      col  ) \n    defined at\n     src/parsefields.jl:338    #  CSV.readline     Method .  read a single line from  io  (any  IO  type) as a string, accounting for potentially embedded newlines in quoted fields (e.g. value1, value2, \"value3 with   embedded newlines\"). Can optionally provide a  buf::IOBuffer  type for buffer resuse  source  #  CSV.readsplitline     Function .  read a single line from  io  (any  IO  type) as a  Vector{String}  with elements being delimited fields. Can optionally provide a  buf::IOBuffer  type for buffer resuse  source  Methods   \n     readsplitline ( io :: IO ) \n    defined at\n     src/io.jl:31   \n     readsplitline ( io :: IO ,  d :: UInt8 ) \n    defined at\n     src/io.jl:31   \n     readsplitline ( \n     io :: IO ,      d :: UInt8 ,      q :: UInt8  ) \n    defined at\n     src/io.jl:31   \n     readsplitline ( \n     io :: IO ,      d :: UInt8 ,      q :: UInt8 ,      e :: UInt8  ) \n    defined at\n     src/io.jl:31   \n     readsplitline ( \n     io :: IO ,      d :: UInt8 ,      q :: UInt8 ,      e :: UInt8 ,      buf :: Base.AbstractIOBuffer{Array{UInt8,1}}  ) \n    defined at\n     src/io.jl:31    #  CSV.countlines     Method .  count the number of lines in a file, accounting for potentially embedded newlines in quoted fields  source", 
            "title": "Lower-level utilities"
        }
    ]
}